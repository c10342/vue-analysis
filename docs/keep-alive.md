
首先keep-alive，是一个抽象组件，它接受三个属性，分别是：include，exclude，max。

- include：被匹配的组件将会被缓存
- exclude：被匹配到的数组不会被缓存
- max：最大缓存数量，采用lru缓存策略，超出最大缓存数量时，最近最少使用的组件实例将会被淘汰销毁

然后在`created`生命周期函数中初始化`cache`和`keys`，`cache`是一个对象，用来存储需要缓存的组件。`keys`是一个数组，用来存储每个需要缓存的组件的`key`，就是对应`cache`对象的`key`值

在`mounted`生命周期函数中监听`include`和`exclude`值的变化，当他们发生变化时，找出那些已经被缓存了的组件，但是在新的匹配规则中已经不需要被缓存的组件，将其从`cache`对象中删除，并销毁组件，同时从`keys`数组中移除对应的`key`值

在`render`函数中：
1、获取默认插槽的第一个组件节点，keep-alive只处理第一个子元素，2、获取组件的name字段，如果name字段不存在就获取组件的tag名称
3、用`name`字段跟`include`和`exclude`中的匹配规则去进行匹配。如果跟`include`不匹配或者跟`exclude`匹配，说明是不需要进行缓存的，直接返回`VNode`。否则走下一步缓存
4、如果是需要缓存，首先获取组件的`key`值，如果VNode有key值，使用这个key值，如果没有key值，就使用实例的构造函数的cid+组件标签名作为key值。
5、根据key值从`cache`对象中查找是否命中了缓存，如果是命中了，直接从缓存在拿出VNode组件的实例，并调整组件的key值在keys数组中的顺序，将其从原来的位置删除，放到数组的最后一位。
6、如果没有命中缓存，则缓存组件，并把组件的key值放置到keys数组中的最后一位。并且如果配置了max属性并且缓存长度超出了max值，则从keys数组中拿出第一个key，因为每次组件命中缓存或者新增的组件的缓存，都会将组件的key放置到`keys`数组的最后一位，这样子最近最少使用的就会排在第一位，所以需要淘汰第一个key值对应的组件。根据这个key找出`cache`对象中缓存的组件，将其从`cache`对象中删除，并销毁组件，同时也需要将key值从`keys`数组中删除。
7、最后设置`keepAlive`标记位