# computed 实现

computed 本质上也是通过`Watcher`类实现的，服务端渲染是没有缓存效果的，是直接通过调用函数获取的结果

1、首先每个 vue 实例上面都会有`_computedWatchers`属性来存储每个计算属性的 watcher 实例

2、`Watcher`在初始化的时候传入 4 个参数，第一个是`vm`实例，第二个是`getter`函数（也就是用户定义计算属性的那个函数），第三个是空函数（没有啥作用），第四个参数是 options 配置项，配置项包含了`lazy`字段，值为`true`，用来标识这是一个计算属性的`Watcher`。`Watcher`在初始化的时候，如果是一个计算属性的`Watcher`，并不会去立刻调用`get`函数去读取值（只有真正被读取到的时候才会去触发依赖收集），同时会初始化`this.lazy`来标识这是一个计算属性的`Watcher`，`this.dirty`标识所依赖的数据是否发生改变

3、通过调用`createComputedGetter`来给计算属性创建一个`getter`函数。这个`getter`函数首先根据 key 值获取对应的`watcher`实例。通过判断`dirty`字段是否为 true 来重新计算计算属性的值，最终吧`value`字段返回

4、当用户真正第一次使用这个计算属性的时候，就会计算对应的值，也就是调用了`Watcher`实例的`get`函数，从而触发了依赖收集，计算属性的`watcher`实例会被收集到所依赖的数据的依赖管理器当中。

5、当依赖的数据发生变化时，会通知更新，也就是调用了`Watcher`实例的`update`函数，`update`函数会把`dirty`值变为`true`，表示依赖的数据发生了变化。当用户再次读取该计算属性的时候，发现`dirty`值为`true`，就会重新计算值，然后再把`dirty`变为`fasle`，下次用户再次读取的时候，因为`dirty`为`false`，不会重新计算，直接返回了上一次计算的值,所以达到了缓存的效果
