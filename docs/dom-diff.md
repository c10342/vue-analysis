# 虚拟DOM

通过一个js对象来描述DOM节点。虚拟DOM包含真实DOM节点所需要的一系列属性，比如`tag`表示节点标签，`text`表示节点中包含文本，`children`表示该节点包含的子节点等等。

**VNode类型**

- 注释节点
- 文本节点
- 元素节点
- 组件节点
- 函数式组件节点
- 克隆节点

# patch 过程

核心：以新的VNode为基准，改造旧的VNode，使之成为跟新的VNode一样，这就是patch过程要干的事情

三件事：

- 创建节点：新的VNode有而旧的VNode没有，就在旧的VNode中创建

- 删除节点：新的VNode没有而旧的VNode有，就从旧的VNode中删除

- 更新节点：新的VNode和旧的VNode都有，以新VNode为基准，更新旧的VNode

# 创建节点

- 根据`tag`判断是否为元素节点，是就创建元素节点，不是就走下一步

- 根据`isComment`判断是否为注释节点，是就创建注释节点，不是就走下一步

- 既不是注释节点，也不是元素节点，那就认为是文本节点。创建文本节点

# 更新节点（patchVNode）

1、新旧节点完全是一样的（`===`比较），就退出程序

2、新旧节点都是静态节点，退出程序

3、如果新VNode是文本节点，并且跟旧的VNode的文本内容不一样，那么无论旧的VNode节点是什么，用新VNode的文本替换真实DOM的内容

4、如果新VNode有子节点
    1、如果新旧VNode都有子节点，调用`updateChildren`函数更新知子节点
    2、只有新Vnode有子节点，旧VNode没有子节点
        1、如果旧的VNode有文本节点，清空文本节点，再把新Vnode的子节点添加到真实DOM中
        2、如果旧的VNode没有文本节点，吧新Vnode的子节点添加到真实DOM中

5、只有旧节点有子节点，并且新VNode也没有子节点的情况，清空DOM中的子节点

6、新旧VNode都没有子节点，但是旧Vnode有文本节点，清空DOM中的文本节点


# 更新孩子节点（updateChildren）

1、准备4个指针，分别指向新孩子节点的第一个位置和最后一个位置，旧孩子节点的第一个位置和最后一个位置

2、以新前，新后，旧前，旧后的方式开始对比节点

3、如果旧前指向的节点不存在，旧前指针自增，对比下一个

4、如果旧后指向的节点不存在，旧后指针自减，对比下一个

5、新前和旧前对比，如果相同，就把2个节点进行`patchVNode`更新，新前，旧前和新前指针自增，对比下一个

6、新后与旧后对比，如果相同，就把2个节点进行`patchVNode`更新，新后，旧后和新前指针自减，对比下一个

7、新后与旧前对比，如果相同，先把2个节点进行`patchVNode`更新，然后把旧前指针指向的节点移动到所有未处理的旧孩子节点的后面，旧前指针自增，新后指针自减

8、新前与旧后对比，如果相同，先把2个节点进行`patchVNode`更新，然后把旧后指针指向的节点移动到所有未处理的旧孩子节点的前面，新前指针自增，旧后指针自减

10、如果都不属于之前的几种情况，就进行常规的循环对比
    1、首先获取旧前指针和旧后指针之间的旧孩子节点的key值和下标索引值，以`key-val`的形式存储，key是节点的key值，val是节点的下标索引。然后将其缓存起来
    2、查找当前循环的节点，也就是新前指针所指向的节点，在旧孩子节点中的下标索值。如果新前节点存在key值，则通过key值在前面缓存的key-val键值对中查找对应的下标索引。如果新前节点不存在key值，则通过循环，将新前节点跟旧前和旧后指针之间的节点，通过调用`sameVnode`方法进行对比，如果新前节点跟旧孩子节点中的节点相同则返回下标索引
    3、如果下标索引不存在，则说明是新增的节点
    4、如果下标索引号存在，则还要调用`sameVnode`方法判断当前循环的节点，跟下标索引所对应的旧孩子节点是否为同一个节点，如果一样，则调用`patchVnode`方法更新节点，然后移动节点。否则就是key值相同，但是为不同元素，默认为新增节点
    5、新前指针自增

11、循环结束后：
    1、如果旧的孩子节点比新的孩子节点先循环完毕，那么，新孩子节点剩下的节点就是需要新增的节点，把新前的指针和新后的指针之间的节点插入到DOM中
    2、如果新孩子节点比旧孩子节点先循环完毕，那么旧孩子节点剩下的节点都是需要删除的节点，把旧前指针和旧后指针之间的节点都删除了


但是我觉得这段代码还可以进行优化。针对常规循坏对比中，没有key值的情况进行优化。因为在没有key值的情况下，获取当前循环的节点在旧孩子节点中的下标索引，是通过`for`循环进行对比的，里面就是通过调用`sameVnode`方法判断当前循环的节点跟旧孩子节点中的节点是否有相同，找到相同的则返回下标索引号，找不到相同的就返回了`undefined`，在找到下标索引的情况下，在原来的逻辑中，又调用了一次`sameVnode`方法来判断当前循环的节点跟下标索引所指向的旧孩子节点是否相同，其实这一步是多余的，因为通过`for`循环找出来的下标索引号所对应的旧孩子节点肯定是跟当前循环的节点是相同节点的，所以可以直接跳过调用`sameVnode`这一步，直接调用`patchVnode`方法进行更新即可。

所以我们可以记录一下获取下标索引号的方式，如果是通过key值获取的方式，则走正常的逻辑。如果是通过`for`循环获取下标索引号的方式，则在找到下标索引号的情况下，直接调用`patchVnode`进行更新节点即可