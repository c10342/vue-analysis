# Vue.extend

## 作用

使用基础的`vue`构造器，创建一个子类。参数是包含组件选项的对象。其中`data`必须是函数

## 原理分析

1、获取父类的`cid`

2、从对象参数中获取缓存池，根据父类的`cid`判断缓存池中是否已经在之前创建过改子类。是，就直接返回缓存的。这是为了`vue`的性能考虑的。对于同一个组件选项对象，反复调用`vue.extend`返回的是同一个结果的

3、获取组件的 name 字段，校验组件名字是否合法

4、通过函数的方式创建一个`sub`类，并将父类的原型链继承到子类中（原型链继承方式），同时还需要修正`constructor`的指向

5、将父类的`options`字段和传入组件对象选项进行合并，并保存在子类`sub`的`options`字段中

6、将父类保存到子类的 super 字段中，确保子类能拿到父类

7、初始化`props`，实际上是代理到`_props`属性。根组件的 props 是在这里进行数据劫持的。好处就是不用为每个组件的实例都做一层 proxy，这是一种优化手段

8、初始化`computed`

9、将父类的`extend`，`mixin`等全局 API 添加到子类中

10、如果`name`字段存在，则给子类`sub`添加`name`字段，方便进行组件递归

11、新增`superOptions`，`extendOptions`等子类独有的属性

12、将构造出来的子类`sub`放进缓存池，`key`值为父类的`cid`

13、返回子类`sub`

# vm.$watch

1、给 options 参数，添加`user`字段，用来区分用户创建的 watcher 和 vue 内部创建的 watcher 实例

2、实例化一个`watcher`实例，传入`组件实例vm`，`表达式`，`回调函数`，`options`选项

3、如果传入了`immediate`选项，并且为`true`，则立即调用回调函数

4、返回一个函数，用来取消监听

# vm.$set 和 Vue.set

1、如果`target`对象为`原始类型`或者`undefined`、`null`，则警告报错

2、如果是数组，并且下标索引是有效的合法值，就会取原数组的长度和传入的下标索引值的最大值作为数组的长度，然后调用`splice`方法添加数据，因为`splice`方法被重写了，会把元素自动转化为响应式，并通知更新。返回`val`值

3、如果是对象，并且`key`值已经在目标对象上面了，说明已经是个响应式数据了，直接赋值即可，并返回

4、如果`key`值不在目标对象上面，先判断目标对象是否为 vue 实例或者 vue 实例的根数据独享，是，则报错，退出程序；然后在判断目标对象上面的`__ob__`属性是否存在，不存在，说明目标对象并不是一个响应式数据，直接赋值，并退出程序。最后通过调用`defineReactive`函数添加新属性，并转化为响应式数据，通知更新，退出程序

注意：为什么数组不需要判断`__ob__`属性是否存在？因为如果是数组是一个响应式数据，那么，调用`splice`方法是重写过后的，如果不是响应式数据，那么，`splice`方法是原生的数组方法

# vm.$delete 和 Vue.delete

1、如果`target`对象为`原始类型`或者`undefined`、`null`，则警告报错

2、如果目标对象是数组，并且下标索引值为有效的，则调用`splice`方法进行删除

3、如果目标对象是 vue 实例或者是 vue 实例的根数据，则退出，并报错提示

4、如果 key 本来就不存在与目标对象中，则退出函数，什么都不用干

5、使用`delete`关键字删除属性值，

6、通知更新

# vm.$forceUpdate

作用：迫使 `Vue` 实例重新渲染。注意它仅仅影响实例本身和插入插槽内容的子组件，而不是所有子组件。

原理：调用组件的`watcher`实例的`update`函数进行更新

# vm.$nextTick 和 vue.nextTick

`vue`中对`DOM`的更新策略是异步的。只要监听到数据变化，`vue`将会开启一个事件队列，并缓冲同一事件循环中的所有数据变化。如果同一个`watcher`被触发多次，只会被推入到事件队列中一次，防止不必要的计算和`DOM`操作。

优先使用微任务。`Promise`->`MutationObserver`->`setImmediate`->`setTimeout`。

`nextTick`会将回调函数推入到回调队列中。在接受到第一个回调函数的时候，使用异步锁，上锁执行异步方法。此时，浏览器处于等待执行完同步代码就执行异步代码的情况。最后，如果没传入回调函数，并且浏览器支持`Promise`，那么就返回一个 promise 实例

# vue.directive、vue.filter、vue.component

实际上是保存到`vue.options`中，这样子组件在合并选项的时候就可以拥有这些全局变量了

# vue.use

1、检查是否已经安装过了，防止重复安装

2、从第二个参数开始，获取剩余的参数，同时将`this`，也就是`vue`插入到参数数组的第一个位置，因为后续调用`install`的时候，vue 参数必须是作为第一个

3、如果`plugin`提供了`install`方法，那么，就调用`plugin.install`方法。如果`plugin`是一个函数，那么，就执行函数

4、最后将插件添加到插件列表中

# Vue.mixin

将传入的`mixin`对象与`this.options`合并，然后将合并后的新对象赋值给`this.options`
