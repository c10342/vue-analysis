# 生命周期

vue 实例的生命收起大致可以分为 4 个阶段，分别如下：

- 初始化阶段：为 vue 实例初始化一些属性，事件，以及响应式数据
- 模板编译阶段：将模板编译成渲染函数
- 挂在阶段：将实例挂载到指定的`DOM`上，即将模板渲染到真实`DOM`中
- 销毁阶段：将实例自身从父组件中删除，并取消依赖追踪和事件监听器

## 初始化

初始化阶段所做的工作大致分为两部分：第一部分是`new vue()`，也就是创建一个`vue`实例；第二部分就是为创建好的`vue`实例初始化一些事件、属性、响应式数据等

**`new vue()`阶段：**

- 利用`instanceof`，检查当前实例是否通过`new`关键字初始化的
- 调用原型链上面`_init`方法，进行初始化，这个方法是在`initMixin`函数中添加上去的
    - 将`vue`实例赋值给`vm`，并且吧用户传递的`options`选项和当前构造函数的`options`属性，以及父级构造函数的`options`属性进行合并，得到一个新的属性，并挂载到`vm.$options`上
    - 通过调用一些初始化函数来`vue`实例初始化一些属性，事件，响应式数据等
        - initLifecycle，初始化生命周期：挂载一些属性，$parent,$root,$children等
        - initEvents，初始化事件相关：将父组件向子组件注册的事件注册到子组件的实例中
        - initRender，初始化渲染相关的：$slots，$scopedSlots，createElement，$attrs，$listeners等数据
        - 调用`beforeCreate`生命周期函数
        - initInjections，初始化inject
        - initState，初始化data，props，methods，computed，watch
        - initProvide，初始化provide 
        - 调用生命周期
    - 所有初始化工作完成之后，最后，会判断用户是否传入了`el`选项，如果传入了，则调用`$mounted`函数进入模板编译和挂载阶段。如果没有传入，则不进入下一个生命周期阶段，需要用户手动调用`$mounted`函数才会进入到下一个生命周期阶段

**initLifecycle函数**

这个函数主要是初始化一些属性包括以`$`开头给外部使用的属性，以`_`开头给内部使用的属性

查找当前组件的直接父组件（不能是抽象组件，会直接跳过抽象组件），并把自身实例添加到父组件的`$children`中。添加`$root`根节点组件

**initEvents函数**

该函数内部实际上会在实例上面新增一个`_events`属性的空对象，用来存储事件，接着调用`updateComponentListeners`函数，将父组件向子组件注册的事件注册到子组件实例的`_events`对象中

模板编译解析的时候，会调用`processAttrs`方法解析标签中的属性，如果是指令，会解析出属性的修饰符，然后如果判断出是事件指令，就会根据修饰符对事件名做处理，如果是浏览器原生事件，就添加到`nativeEvents`属性中，如果是自定义事件，就会添加到`events`属性中，并把回调函数的字符串保留到对应的事件中。最后在创建组件的时候，把自定义事件传给子组件，在子组件实例化的时候进行初始化；而浏览器原生事件是在父组件中处理。

换句话说：实例初始化阶段调用的初始化事件函数initEvents实际上初始化的是父组件在模板中使用v-on或@注册的监听子组件内触发的事件

**initInjections函数**

该函数主要是从当前组件起，不断向上游父级组件的`_provided`属性中查找是否提供了该数据对应的值，直到找到为止。如果没有找到，就看是否提供了默认值，有就使用默认值，没有就抛出异常。最后把查找出来的`key-val`键值对添加到当前实例上

**initState函数**

该函数首先添加一个`_watchers`的属性，用来存储当前实例上面的所有`watcher`实例

注意：从Vue 2.0版本起，Vue不再对所有数据都进行侦测，而是将侦测粒度提高到了组件层面，对每个组件进行侦测，所以在每个组件上新增了vm._watchers属性，用来存放这个组件内用到的所有状态的依赖，当其中一个状态发生变化时，就会通知到组件，然后由组件内部使用虚拟DOM进行数据比对，从而降低内存开销，提高性能

然后开始按顺序初始化`props`，`methods`，`data`，`computed`，`watcher`

`initProps`

- 检验props的值是否合法。其中布尔类型的比较特殊

1、父组件没有传入`prop`属性，并且也没有默认属性，就设置为`false`
2、父组件传入了`prop`属性，属性值为空字符串或者属性名和属性值相等，并且`prop`属性不存在`string`类型或者`boolean`类型的优先级比`string`类型的优先级高，就设置为`true`

- 如果`prop`属性不在`this`上面，就将`prop`属性代理到`this`上面

**initMethods函数**

- 检查`methods`中的每一个方法必须是一个函数

- 检查methods中的方法是否跟props中的重名

- 如果实例中有对应的key值，并且以_或者$开头的，提示命名不规范

- 将方法代理到this上面

**initData函数**

- 获取data对象，如果data不是一个对象，则报错警告

- 检查是否跟`methods`和`props`有重名的

- 将不以_或者$开头的属性代理到this上面

- 将`data`对象转化为响应式对象

## 模板编译阶段

运行时版本和完整版本区别只是在于完整版本多了编译模板这个阶段，运行时版本会跳过模板编译阶段，因为，模板已经预先通过`vue-loader`编译好了

## 挂载阶段

1、`$mounted`函数实际上调用的是`mountComponent`函数，该函数首先判断是否存在`render`函数，如果不存在，则给一个默认的渲染函数，该渲染函数会创建一个注释类型的`VNode`节点，然后给出警告。

2、触发`beforeMount`声明周期函数

3、定义`updateComponent`函数，该函数内部首先执行`render`渲染函数，得到一份最新的`VNode`节点树，然后执行`_update`方法对最新的`Vnode`节点和上一次的`VNode`节点进行对比，并更新`DOM`元素（即`patch`操作），完成一次渲染。这样子完成了挂载操作的一半工作。

4、另一半工作是开启对模板中的数据监控，当数据发生变化时，通知期其依赖进行视图更新。首先创建一个`watcher`实例，并将定义好的`updateComponent`函数作为第二个参数传入，watcher构造函数的第二个参数支持2种类型，一种是数据路径，另外一种是函数。如果是数据路径，就会根据路径去读取这个数据，如果是函数，就会执行函数，一旦读取了数据或者执行了函数，就会触发数据的`getter`方法，`getter`方法会将`watcher`实例添加到改数据的依赖列表中，，当数据发生变化时，就会通知依赖列表进行更新，当依赖接收到通知后，就会调用第四个参数回调函数去更新视图。

换句话来说，`updateComponent`函数所使用到的数据都会被`watcher`监控，只要这些数据发生了变化，那么`watcher`都将会得到通知，从而掉用第四个参数回调函数去更新视图

## 销毁阶段

1、根据`isBeginDestroyed`属性判断当前实例是否处于被销毁状态，防止反复执行销毁逻辑，然后触发`beforeDestroy`生命周期函数

2、首选将当前vue实例从父级实例的`$children`中删除

3、接着将自己身上的依赖追踪移除。实例身上的依赖分2部分:一部分是实例自身依赖的数据，另一部分是实力内的数据对其他数据的依赖（$watcher创建的），所以删除依赖的时候需要将这2部分都删除掉

4、移除实例内的响应式数据的引用，给当前实例上添加`isDestroyed`属性来标识当前实例已经被销毁，同时将实例的`VNode`数设置为`null`

5、触发`destroyed`生命周期函数

6、调用`vm.$off`方法，移除实例上面的所有事件监听器

