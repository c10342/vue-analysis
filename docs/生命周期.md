# 生命周期

vue 实例的生命收起大致可以分为 4 个阶段，分别如下：

- 初始化阶段：为 vue 实例初始化一些属性，事件，以及响应式数据
- 模板编译阶段：将模板编译成渲染函数
- 挂在阶段：将实例挂载到指定的`DOM`上，即将模板渲染到真实`DOM`中
- 销毁阶段：将实例自身从父组件中删除，并取消依赖追踪和事件监听器

## 初始化

初始化阶段所做的工作大致分为两部分：第一部分是`new vue()`，也就是创建一个`vue`实例；第二部分就是为创建好的`vue`实例初始化一些事件、属性、响应式数据等

**`new vue()`阶段：**

- 利用`instanceof`，检查当前实例是否通过`new`关键字初始化的
- 调用原型链上面`_init`方法，进行初始化，这个方法是在`initMixin`函数中添加上去的
    - 将`vue`实例赋值给`vm`，并且吧用户传递的`options`选项和当前构造函数的`options`属性，以及父级构造函数的`options`属性进行合并，得到一个新的属性，并挂载到`vm.$options`上
    - 通过调用一些初始化函数来`vue`实例初始化一些属性，事件，响应式数据等
        - initLifecycle，初始化生命周期：挂载一些属性，$parent,$root,$children等
        - initEvents，初始化事件相关：将父组件向子组件注册的事件注册到子组件的实例中
        - initRender，初始化渲染相关的：$slots，$scopedSlots，createElement，$attrs，$listeners等数据
        - 调用`beforeCreate`生命周期函数
        - initInjections，初始化inject
        - initState，初始化data，props，methods，computed，watch
        - initProvide，初始化provide 
        - 调用生命周期
    - 所有初始化工作完成之后，最后，会判断用户是否传入了`el`选项，如果传入了，则调用`$mounted`函数进入模板编译和挂载阶段。如果没有传入，则不进入下一个生命周期阶段，需要用户手动调用`$mounted`函数才会进入到下一个生命周期阶段

**initLifecycle函数**

这个函数主要是初始化一些属性包括以`$`开头给外部使用的属性，以`_`开头给内部使用的属性

查找当前组件的直接父组件（不能是抽象组件，会直接跳过抽象组件），并把自身实例添加到父组件的`$children`中。添加`$root`根节点组件

**initEvents函数**

该函数内部实际上会在实例上面新增一个`_events`属性的空对象，用来存储事件，接着调用`updateComponentListeners`函数，将父组件向子组件注册的事件注册到子组件实例的`_events`对象中

模板编译解析的时候，会调用`processAttrs`方法解析标签中的属性，如果是指令，会解析出属性的修饰符，然后如果判断出是事件指令，就会根据修饰符对事件名做处理，如果是浏览器原生事件，就添加到`nativeEvents`属性中，如果是自定义事件，就会添加到`events`属性中，并把回调函数的字符串保留到对应的事件中。最后在创建组件的时候，把自定义事件传给子组件，在子组件实例化的时候进行初始化；而浏览器原生事件是在父组件中处理。

换句话说：实例初始化阶段调用的初始化事件函数initEvents实际上初始化的是父组件在模板中使用v-on或@注册的监听子组件内触发的事件

**initInjections函数**

该函数主要是从当前组件起，不断向上游父级组件的`_provided`属性中查找是否提供了该数据对应的值，直到找到为止。如果没有找到，就看是否提供了默认值，有就使用默认值，没有就抛出异常。最后把查找出来的`key-val`键值对添加到当前实例上

**initState函数**

该函数首先添加一个`_watchers`的属性，用来存储当前实例上面的所有`watcher`实例

注意：从Vue 2.0版本起，Vue不再对所有数据都进行侦测，而是将侦测粒度提高到了组件层面，对每个组件进行侦测，所以在每个组件上新增了vm._watchers属性，用来存放这个组件内用到的所有状态的依赖，当其中一个状态发生变化时，就会通知到组件，然后由组件内部使用虚拟DOM进行数据比对，从而降低内存开销，提高性能

然后开始按顺序初始化`props`，`methods`，`data`，`computed`，`watcher`